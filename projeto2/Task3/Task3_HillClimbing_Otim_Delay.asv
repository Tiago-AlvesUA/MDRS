function [sol, load,Loads,linkEnergy]= Task3_HillClimbing_Otim_Delay(sol, nNodes,Links,T,D,sP,nSP,L,nFlows1)
    nFlows = size(T,1);
        
    T1_idx = 1:nFlows1;
    T2_idx = 1+nFlows1:nFlows;

    Loads= calculateLinkLoads(nNodes,Links,T,L,sP,sol);
    load= max(max(Loads(:,3:4)));

    bestDelay = calculateServiceDelays(sP, sol, D, T);
    
    improved = true;
    while improved
        bestNeighDelay = inf;
        for flow= 1:nFlows 
            for path= 1:nSP(flow) %Rodar por todos os vizinhos possiveis
                if sol(flow)~=path %NÃ£o trocar a sol por ela mesma
                    auxsol = sol;
                    auxsol(flow)= path;
                    [auxLoads,auxLinkEnergy]= calculateLinkLoads(nNodes,Links,T,L,sP,auxsol);
                    % delay of this sol
                    auxDelay = calculateServiceDelays(sP, auxsol, D, T);

                    sumAuxDelay = sum(auxDelay(T1_idx)) + 0.5 * sum(auxDelay(T2_idx));
                    sumBestDelay = sum(bestNeighDelay(T1_idx)) + 0.5 * sum(bestNeighDelay(T2_idx));
                    
                    if sumAuxDelay < sumBestDelay
                        energyBestNeigh = auxLinkEnergy;
                        LoadsBestNeigh = auxLoads;
                        bestSol = auxsol;
                        delay = auxDelay;
                    end
                end
            end
        end
        if max(bestNeighDelay(T1_idx)) < delay % Encontrado melhor vizinho, trocar valores
            % delay = bestDelay;
            % energy = energyBestNeigh;
            % Loads = LoadsBestNeigh;
            sol = bestSol;
            load = max(bestNeighDelay(T1_idx));
            if Loads == inf
                load = inf;
            end
        else
            load = max(calculateServiceDelays(sP, sol, D, T));
            improved = false;
        end
    end
end
